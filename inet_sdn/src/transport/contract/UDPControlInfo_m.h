//
// Generated file, do not edit! Created by nedtool 4.6 from transport/contract/UDPControlInfo.msg.
//

#ifndef _UDPCONTROLINFO_M_H_
#define _UDPCONTROLINFO_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif



// cplusplus {{
#include "IPvXAddress.h"
// }}

/**
 * Enum generated from <tt>transport/contract/UDPControlInfo.msg:34</tt> by nedtool.
 * <pre>
 * //
 * // UDP command codes, sent by the application to ~UDP. These constants
 * // should be set as message kind on messages sent to the ~UDP entity.
 * //
 * // @see ~UDPControlInfo, ~UDPStatusInd, ~UDP
 * //
 * enum UDPCommandCode
 * {
 * 
 *     UDP_C_DATA = 0;      // send()/sendTo(); see ~UDPSendCommand
 *     UDP_C_BIND = 1;      // bind(); see ~UDPBindCommand
 *     UDP_C_CONNECT = 2;   // connect(); see ~UDPConnectCommand
 *     UDP_C_SETOPTION = 3; // setsockopt(); see ~UDPSetTimeToLiveCommand,...
 *     UDP_C_CLOSE = 4;     // close(); see ~UDPCloseCommand
 * }
 * </pre>
 */
enum UDPCommandCode {
    UDP_C_DATA = 0,
    UDP_C_BIND = 1,
    UDP_C_CONNECT = 2,
    UDP_C_SETOPTION = 3,
    UDP_C_CLOSE = 4
};

/**
 * Enum generated from <tt>transport/contract/UDPControlInfo.msg:50</tt> by nedtool.
 * <pre>
 * //
 * // UDP indications, sent by ~UDP to the application. ~UDP will set these
 * // constants as message kind on messages it sends to the application.
 * //
 * // @see ~UDPControlInfo, ~UDPCommandCode, ~UDP
 * //
 * enum UDPStatusInd
 * {
 * 
 *     UDP_I_DATA = 0;  // ~UDP attaches ~UDPIndication to received data packet
 *     UDP_I_ERROR = 1; // ~UDP attaches ~UDPIndication to received data packet
 * }
 * </pre>
 */
enum UDPStatusInd {
    UDP_I_DATA = 0,
    UDP_I_ERROR = 1
};

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:66</tt> by nedtool.
 * <pre>
 * //
 * // Base class for UDP control info classes. The most convenient way to handle
 * // ~UDP is the UDPSocket class, which hides control info from you.
 * //
 * // sockId must uniquely identify the socket in the ~UDP module; the best way
 * // to achieve that is to obtain the value from UDPSocket::generateSocketId().
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPControlInfo
 * {
 *     int sockId = -1;  // must uniquely identify the socket in the ~UDP module
 * }
 * </pre>
 */
class INET_API UDPControlInfo : public ::cObject
{
  protected:
    int sockId_var;

  private:
    void copy(const UDPControlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPControlInfo&);

  public:
    UDPControlInfo();
    UDPControlInfo(const UDPControlInfo& other);
    virtual ~UDPControlInfo();
    UDPControlInfo& operator=(const UDPControlInfo& other);
    virtual UDPControlInfo *dup() const {return new UDPControlInfo(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSockId() const;
    virtual void setSockId(int sockId);
};

inline void doPacking(cCommBuffer *b, UDPControlInfo& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:81</tt> by nedtool.
 * <pre>
 * //
 * // Control info for binding an UDP socket. To create and bind a socket,
 * // send a message to the ~UDP module with kind=UDP_C_BIND and an
 * // ~UDPBindCommand attached.
 * //
 * // Both the address and the port may be left unset. If the port is
 * // unset, ~UDP will assign an ephemeral port.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPBindCommand extends UDPControlInfo
 * {
 *     IPvXAddress localAddr;
 *     int localPort = -1;
 * }
 * </pre>
 */
class INET_API UDPBindCommand : public ::UDPControlInfo
{
  protected:
    IPvXAddress localAddr_var;
    int localPort_var;

  private:
    void copy(const UDPBindCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPBindCommand&);

  public:
    UDPBindCommand();
    UDPBindCommand(const UDPBindCommand& other);
    virtual ~UDPBindCommand();
    UDPBindCommand& operator=(const UDPBindCommand& other);
    virtual UDPBindCommand *dup() const {return new UDPBindCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPvXAddress& getLocalAddr();
    virtual const IPvXAddress& getLocalAddr() const {return const_cast<UDPBindCommand*>(this)->getLocalAddr();}
    virtual void setLocalAddr(const IPvXAddress& localAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
};

inline void doPacking(cCommBuffer *b, UDPBindCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPBindCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:97</tt> by nedtool.
 * <pre>
 * //
 * // Control info for connecting an UDP socket. To connect a socket,
 * // send a message to the ~UDP module with kind=UDP_C_CONNECT and an
 * // ~UDPConnectCommand attached. If the socket does not exist,
 * // it will be created.
 * //
 * // Both the address and the port must be filled in.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPConnectCommand extends UDPControlInfo
 * {
 *     IPvXAddress remoteAddr;
 *     int remotePort = -1;
 * }
 * </pre>
 */
class INET_API UDPConnectCommand : public ::UDPControlInfo
{
  protected:
    IPvXAddress remoteAddr_var;
    int remotePort_var;

  private:
    void copy(const UDPConnectCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPConnectCommand&);

  public:
    UDPConnectCommand();
    UDPConnectCommand(const UDPConnectCommand& other);
    virtual ~UDPConnectCommand();
    UDPConnectCommand& operator=(const UDPConnectCommand& other);
    virtual UDPConnectCommand *dup() const {return new UDPConnectCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPvXAddress& getRemoteAddr();
    virtual const IPvXAddress& getRemoteAddr() const {return const_cast<UDPConnectCommand*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const IPvXAddress& remoteAddr);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
};

inline void doPacking(cCommBuffer *b, UDPConnectCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPConnectCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:114</tt> by nedtool.
 * <pre>
 * //
 * // Control info for sending data via UDP. To send a packet, send it to
 * // the ~UDP module with kind=UDP_C_SEND and an ~UDPSendCommand attached.
 * //
 * // UDP_C_SEND/~UDPSendCommand models both the Unix send() and sendto() calls.
 * // If the socket is connected, destAddr/destPort may be left blank (send()),
 * // otherwise it must contain the destination for the packet (sendto()).
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPSendCommand extends UDPControlInfo
 * {
 *     IPvXAddress destAddr; // destination IPv4 or IPv6 address
 *     int destPort = -1;     // destination port
 *     IPvXAddress srcAddr;       // source address
 *     int interfaceId = -1; // interface on which the packet must be sent (see ~InterfaceTable)
 * }
 * </pre>
 */
class INET_API UDPSendCommand : public ::UDPControlInfo
{
  protected:
    IPvXAddress destAddr_var;
    int destPort_var;
    IPvXAddress srcAddr_var;
    int interfaceId_var;

  private:
    void copy(const UDPSendCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSendCommand&);

  public:
    UDPSendCommand();
    UDPSendCommand(const UDPSendCommand& other);
    virtual ~UDPSendCommand();
    UDPSendCommand& operator=(const UDPSendCommand& other);
    virtual UDPSendCommand *dup() const {return new UDPSendCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPvXAddress& getDestAddr();
    virtual const IPvXAddress& getDestAddr() const {return const_cast<UDPSendCommand*>(this)->getDestAddr();}
    virtual void setDestAddr(const IPvXAddress& destAddr);
    virtual int getDestPort() const;
    virtual void setDestPort(int destPort);
    virtual IPvXAddress& getSrcAddr();
    virtual const IPvXAddress& getSrcAddr() const {return const_cast<UDPSendCommand*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const IPvXAddress& srcAddr);
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
};

inline void doPacking(cCommBuffer *b, UDPSendCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSendCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:129</tt> by nedtool.
 * <pre>
 * //
 * // Control info for closing an UDP socket. To close a socket, send a message
 * // to the ~UDP module with kind=UDP_C_CLOSE and an ~UDPCloseCommand attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPCloseCommand extends UDPControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UDPCloseCommand : public ::UDPControlInfo
{
  protected:

  private:
    void copy(const UDPCloseCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPCloseCommand&);

  public:
    UDPCloseCommand();
    UDPCloseCommand(const UDPCloseCommand& other);
    virtual ~UDPCloseCommand();
    UDPCloseCommand& operator=(const UDPCloseCommand& other);
    virtual UDPCloseCommand *dup() const {return new UDPCloseCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, UDPCloseCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPCloseCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:140</tt> by nedtool.
 * <pre>
 * //
 * // Control info that is attached to received data packets, sent up from the
 * // ~UDP module to the application with UDP_I_DATA as message kind.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPDataIndication extends UDPControlInfo
 * {
 *     IPvXAddress srcAddr;   // source IPv4 or IPv6 address of the received packet
 *     IPvXAddress destAddr;  // destination IPv4 or IPv6 address of the received packet
 *     int srcPort;           // source port of the received packet
 *     int destPort;          // destination port of the received packet
 *     int ttl;               // TTL field of the received packet
 *     int interfaceId;       // interface on which the packet was received (see ~InterfaceTable)
 *     unsigned char typeOfService; // IPv4 Type of Service / IPv6 Traffic Class field of received packet
 * }
 * </pre>
 */
class INET_API UDPDataIndication : public ::UDPControlInfo
{
  protected:
    IPvXAddress srcAddr_var;
    IPvXAddress destAddr_var;
    int srcPort_var;
    int destPort_var;
    int ttl_var;
    int interfaceId_var;
    unsigned char typeOfService_var;

  private:
    void copy(const UDPDataIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPDataIndication&);

  public:
    UDPDataIndication();
    UDPDataIndication(const UDPDataIndication& other);
    virtual ~UDPDataIndication();
    UDPDataIndication& operator=(const UDPDataIndication& other);
    virtual UDPDataIndication *dup() const {return new UDPDataIndication(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPvXAddress& getSrcAddr();
    virtual const IPvXAddress& getSrcAddr() const {return const_cast<UDPDataIndication*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const IPvXAddress& srcAddr);
    virtual IPvXAddress& getDestAddr();
    virtual const IPvXAddress& getDestAddr() const {return const_cast<UDPDataIndication*>(this)->getDestAddr();}
    virtual void setDestAddr(const IPvXAddress& destAddr);
    virtual int getSrcPort() const;
    virtual void setSrcPort(int srcPort);
    virtual int getDestPort() const;
    virtual void setDestPort(int destPort);
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual unsigned char getTypeOfService() const;
    virtual void setTypeOfService(unsigned char typeOfService);
};

inline void doPacking(cCommBuffer *b, UDPDataIndication& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPDataIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:158</tt> by nedtool.
 * <pre>
 * //
 * // Control info that is sent up from the ~UDP module to the application with
 * // UDP_I_ERROR as message kind when ~UDP receives an ICMP error for a packet
 * // previously sent from the socket.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPErrorIndication extends UDPControlInfo
 * {
 *     IPvXAddress srcAddr;   // source IPv4 or IPv6 address of the undeliverable packet
 *     IPvXAddress destAddr;  // destination IPv4 or IPv6 address of the undeliverable packet
 *     int srcPort;           // source port of the undeliverable packet
 *     int destPort;          // destination port of the undeliverable packet
 * }
 * </pre>
 */
class INET_API UDPErrorIndication : public ::UDPControlInfo
{
  protected:
    IPvXAddress srcAddr_var;
    IPvXAddress destAddr_var;
    int srcPort_var;
    int destPort_var;

  private:
    void copy(const UDPErrorIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPErrorIndication&);

  public:
    UDPErrorIndication();
    UDPErrorIndication(const UDPErrorIndication& other);
    virtual ~UDPErrorIndication();
    UDPErrorIndication& operator=(const UDPErrorIndication& other);
    virtual UDPErrorIndication *dup() const {return new UDPErrorIndication(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPvXAddress& getSrcAddr();
    virtual const IPvXAddress& getSrcAddr() const {return const_cast<UDPErrorIndication*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const IPvXAddress& srcAddr);
    virtual IPvXAddress& getDestAddr();
    virtual const IPvXAddress& getDestAddr() const {return const_cast<UDPErrorIndication*>(this)->getDestAddr();}
    virtual void setDestAddr(const IPvXAddress& destAddr);
    virtual int getSrcPort() const;
    virtual void setSrcPort(int srcPort);
    virtual int getDestPort() const;
    virtual void setDestPort(int destPort);
};

inline void doPacking(cCommBuffer *b, UDPErrorIndication& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPErrorIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:169</tt> by nedtool.
 * <pre>
 * //
 * // Base class for UDP socket option control info classes.
 * //
 * class UDPSetOptionCommand extends UDPControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UDPSetOptionCommand : public ::UDPControlInfo
{
  protected:

  private:
    void copy(const UDPSetOptionCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetOptionCommand&);

  public:
    UDPSetOptionCommand();
    UDPSetOptionCommand(const UDPSetOptionCommand& other);
    virtual ~UDPSetOptionCommand();
    UDPSetOptionCommand& operator=(const UDPSetOptionCommand& other);
    virtual UDPSetOptionCommand *dup() const {return new UDPSetOptionCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, UDPSetOptionCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSetOptionCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:181</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Time To Live (a.k.a. Hop Limit) option on an
 * // UDP socket. This option will affect both multicast and unicast packets.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPSetTimeToLiveCommand extends UDPSetOptionCommand
 * {
 *     int ttl;
 * }
 * </pre>
 */
class INET_API UDPSetTimeToLiveCommand : public ::UDPSetOptionCommand
{
  protected:
    int ttl_var;

  private:
    void copy(const UDPSetTimeToLiveCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetTimeToLiveCommand&);

  public:
    UDPSetTimeToLiveCommand();
    UDPSetTimeToLiveCommand(const UDPSetTimeToLiveCommand& other);
    virtual ~UDPSetTimeToLiveCommand();
    UDPSetTimeToLiveCommand& operator=(const UDPSetTimeToLiveCommand& other);
    virtual UDPSetTimeToLiveCommand *dup() const {return new UDPSetTimeToLiveCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
};

inline void doPacking(cCommBuffer *b, UDPSetTimeToLiveCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSetTimeToLiveCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:196</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Type of Service (IPv4) or Traffic Class (IPv6)
 * // header field on outgoing IPv4/IPv6 packets sent from an UDP socket.
 * // This is an 8-bit field, the lowest 6 bits are the DSCP (DiffServ Code Point)
 * // and the highest 2 bits are the ECN (Explicit Congestion Notification).
 * // To set the option, send a message to  the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPSetTypeOfServiceCommand extends UDPSetOptionCommand
 * {
 *     char tos;  // ToS byte for IPv4/IPv6
 * }
 * </pre>
 */
class INET_API UDPSetTypeOfServiceCommand : public ::UDPSetOptionCommand
{
  protected:
    char tos_var;

  private:
    void copy(const UDPSetTypeOfServiceCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetTypeOfServiceCommand&);

  public:
    UDPSetTypeOfServiceCommand();
    UDPSetTypeOfServiceCommand(const UDPSetTypeOfServiceCommand& other);
    virtual ~UDPSetTypeOfServiceCommand();
    UDPSetTypeOfServiceCommand& operator=(const UDPSetTypeOfServiceCommand& other);
    virtual UDPSetTypeOfServiceCommand *dup() const {return new UDPSetTypeOfServiceCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual char getTos() const;
    virtual void setTos(char tos);
};

inline void doPacking(cCommBuffer *b, UDPSetTypeOfServiceCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSetTypeOfServiceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:208</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Broadcast option on an UDP socket.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPSetBroadcastCommand extends UDPSetOptionCommand
 * {
 *     bool broadcast;
 * }
 * </pre>
 */
class INET_API UDPSetBroadcastCommand : public ::UDPSetOptionCommand
{
  protected:
    bool broadcast_var;

  private:
    void copy(const UDPSetBroadcastCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetBroadcastCommand&);

  public:
    UDPSetBroadcastCommand();
    UDPSetBroadcastCommand(const UDPSetBroadcastCommand& other);
    virtual ~UDPSetBroadcastCommand();
    UDPSetBroadcastCommand& operator=(const UDPSetBroadcastCommand& other);
    virtual UDPSetBroadcastCommand *dup() const {return new UDPSetBroadcastCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getBroadcast() const;
    virtual void setBroadcast(bool broadcast);
};

inline void doPacking(cCommBuffer *b, UDPSetBroadcastCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSetBroadcastCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:220</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the multicast output interface for an UDP socket.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPSetMulticastInterfaceCommand extends UDPSetOptionCommand
 * {
 *     int interfaceId;
 * }
 * </pre>
 */
class INET_API UDPSetMulticastInterfaceCommand : public ::UDPSetOptionCommand
{
  protected:
    int interfaceId_var;

  private:
    void copy(const UDPSetMulticastInterfaceCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetMulticastInterfaceCommand&);

  public:
    UDPSetMulticastInterfaceCommand();
    UDPSetMulticastInterfaceCommand(const UDPSetMulticastInterfaceCommand& other);
    virtual ~UDPSetMulticastInterfaceCommand();
    UDPSetMulticastInterfaceCommand& operator=(const UDPSetMulticastInterfaceCommand& other);
    virtual UDPSetMulticastInterfaceCommand *dup() const {return new UDPSetMulticastInterfaceCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
};

inline void doPacking(cCommBuffer *b, UDPSetMulticastInterfaceCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSetMulticastInterfaceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:234</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the multicast loop option for an UDP socket.
 * // When the option is true, a copy of the outgoing multicast packet
 * // is delivered locally via the loopback interface.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an instance of this control info class attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPSetMulticastLoopCommand extends UDPSetOptionCommand
 * {
 *     bool loop;
 * }
 * </pre>
 */
class INET_API UDPSetMulticastLoopCommand : public ::UDPSetOptionCommand
{
  protected:
    bool loop_var;

  private:
    void copy(const UDPSetMulticastLoopCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetMulticastLoopCommand&);

  public:
    UDPSetMulticastLoopCommand();
    UDPSetMulticastLoopCommand(const UDPSetMulticastLoopCommand& other);
    virtual ~UDPSetMulticastLoopCommand();
    UDPSetMulticastLoopCommand& operator=(const UDPSetMulticastLoopCommand& other);
    virtual UDPSetMulticastLoopCommand *dup() const {return new UDPSetMulticastLoopCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getLoop() const;
    virtual void setLoop(bool loop);
};

inline void doPacking(cCommBuffer *b, UDPSetMulticastLoopCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSetMulticastLoopCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:248</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the ReuseAddress option on an UDP socket.
 * // When the option is true, then the socket is allowed to bind to an already bound
 * // local address.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPSetReuseAddressCommand extends UDPSetOptionCommand
 * {
 *     bool reuseAddress;
 * }
 * </pre>
 */
class INET_API UDPSetReuseAddressCommand : public ::UDPSetOptionCommand
{
  protected:
    bool reuseAddress_var;

  private:
    void copy(const UDPSetReuseAddressCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetReuseAddressCommand&);

  public:
    UDPSetReuseAddressCommand();
    UDPSetReuseAddressCommand(const UDPSetReuseAddressCommand& other);
    virtual ~UDPSetReuseAddressCommand();
    UDPSetReuseAddressCommand& operator=(const UDPSetReuseAddressCommand& other);
    virtual UDPSetReuseAddressCommand *dup() const {return new UDPSetReuseAddressCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getReuseAddress() const;
    virtual void setReuseAddress(bool reuseAddress);
};

inline void doPacking(cCommBuffer *b, UDPSetReuseAddressCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPSetReuseAddressCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:264</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket join multicast groups.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // The address-interfaceId pairs are passed as two separate arrays.
 * // When there are less interfaceIds than multicast addresses,
 * // then -1 is assumed (meaning join on all interfaces).
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPJoinMulticastGroupsCommand extends UDPSetOptionCommand
 * {
 *     IPvXAddress multicastAddr[];
 *     int interfaceId[];
 * }
 * </pre>
 */
class INET_API UDPJoinMulticastGroupsCommand : public ::UDPSetOptionCommand
{
  protected:
    IPvXAddress *multicastAddr_var; // array ptr
    unsigned int multicastAddr_arraysize;
    int *interfaceId_var; // array ptr
    unsigned int interfaceId_arraysize;

  private:
    void copy(const UDPJoinMulticastGroupsCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPJoinMulticastGroupsCommand&);

  public:
    UDPJoinMulticastGroupsCommand();
    UDPJoinMulticastGroupsCommand(const UDPJoinMulticastGroupsCommand& other);
    virtual ~UDPJoinMulticastGroupsCommand();
    UDPJoinMulticastGroupsCommand& operator=(const UDPJoinMulticastGroupsCommand& other);
    virtual UDPJoinMulticastGroupsCommand *dup() const {return new UDPJoinMulticastGroupsCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setMulticastAddrArraySize(unsigned int size);
    virtual unsigned int getMulticastAddrArraySize() const;
    virtual IPvXAddress& getMulticastAddr(unsigned int k);
    virtual const IPvXAddress& getMulticastAddr(unsigned int k) const {return const_cast<UDPJoinMulticastGroupsCommand*>(this)->getMulticastAddr(k);}
    virtual void setMulticastAddr(unsigned int k, const IPvXAddress& multicastAddr);
    virtual void setInterfaceIdArraySize(unsigned int size);
    virtual unsigned int getInterfaceIdArraySize() const;
    virtual int getInterfaceId(unsigned int k) const;
    virtual void setInterfaceId(unsigned int k, int interfaceId);
};

inline void doPacking(cCommBuffer *b, UDPJoinMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPJoinMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>transport/contract/UDPControlInfo.msg:278</tt> by nedtool.
 * <pre>
 * //
 * //
 * // Control info for letting an UDP socket leave multicast groups.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // @see ~UDPCommandCode
 * //
 * class UDPLeaveMulticastGroupsCommand extends UDPSetOptionCommand
 * {
 *     IPvXAddress multicastAddr[];
 * }
 * </pre>
 */
class INET_API UDPLeaveMulticastGroupsCommand : public ::UDPSetOptionCommand
{
  protected:
    IPvXAddress *multicastAddr_var; // array ptr
    unsigned int multicastAddr_arraysize;

  private:
    void copy(const UDPLeaveMulticastGroupsCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPLeaveMulticastGroupsCommand&);

  public:
    UDPLeaveMulticastGroupsCommand();
    UDPLeaveMulticastGroupsCommand(const UDPLeaveMulticastGroupsCommand& other);
    virtual ~UDPLeaveMulticastGroupsCommand();
    UDPLeaveMulticastGroupsCommand& operator=(const UDPLeaveMulticastGroupsCommand& other);
    virtual UDPLeaveMulticastGroupsCommand *dup() const {return new UDPLeaveMulticastGroupsCommand(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setMulticastAddrArraySize(unsigned int size);
    virtual unsigned int getMulticastAddrArraySize() const;
    virtual IPvXAddress& getMulticastAddr(unsigned int k);
    virtual const IPvXAddress& getMulticastAddr(unsigned int k) const {return const_cast<UDPLeaveMulticastGroupsCommand*>(this)->getMulticastAddr(k);}
    virtual void setMulticastAddr(unsigned int k, const IPvXAddress& multicastAddr);
};

inline void doPacking(cCommBuffer *b, UDPLeaveMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UDPLeaveMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}


#endif // ifndef _UDPCONTROLINFO_M_H_

