//
// Generated file, do not edit! Created by nedtool 4.6 from networklayer/routing/dymo/DYMO.msg.
//

#ifndef _DYMO_DYMO_M_H_
#define _DYMO_DYMO_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif

// cplusplus {{
#include "IPv4Address.h"
#include "DYMOdefs.h"
// }}


namespace DYMO {

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:36</tt> by nedtool.
 * <pre>
 * class AddressBlock
 * {
 *     IPv4Address address;
 *     int prefixLength;
 *     bool hasValidityTime;
 *     simtime_t validityTime;
 *     bool hasMetric;
 *     double metric;
 *     bool hasMetricType;
 *     DYMOMetricType metricType;
 *     bool hasSequenceNumber;
 *     DYMOSequenceNumber sequenceNumber;
 * }
 * 
 * //
 * // DYMO timer messages
 * //
 * </pre>
 */
class INET_API AddressBlock : public ::cObject
{
  protected:
    IPv4Address address_var;
    int prefixLength_var;
    bool hasValidityTime_var;
    simtime_t validityTime_var;
    bool hasMetric_var;
    double metric_var;
    bool hasMetricType_var;
    DYMOMetricType metricType_var;
    bool hasSequenceNumber_var;
    DYMOSequenceNumber sequenceNumber_var;

  private:
    void copy(const AddressBlock& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AddressBlock&);

  public:
    AddressBlock();
    AddressBlock(const AddressBlock& other);
    virtual ~AddressBlock();
    AddressBlock& operator=(const AddressBlock& other);
    virtual AddressBlock *dup() const {return new AddressBlock(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPv4Address& getAddress();
    virtual const IPv4Address& getAddress() const {return const_cast<AddressBlock*>(this)->getAddress();}
    virtual void setAddress(const IPv4Address& address);
    virtual int getPrefixLength() const;
    virtual void setPrefixLength(int prefixLength);
    virtual bool getHasValidityTime() const;
    virtual void setHasValidityTime(bool hasValidityTime);
    virtual simtime_t getValidityTime() const;
    virtual void setValidityTime(simtime_t validityTime);
    virtual bool getHasMetric() const;
    virtual void setHasMetric(bool hasMetric);
    virtual double getMetric() const;
    virtual void setMetric(double metric);
    virtual bool getHasMetricType() const;
    virtual void setHasMetricType(bool hasMetricType);
    virtual DYMOMetricType& getMetricType();
    virtual const DYMOMetricType& getMetricType() const {return const_cast<AddressBlock*>(this)->getMetricType();}
    virtual void setMetricType(const DYMOMetricType& metricType);
    virtual bool getHasSequenceNumber() const;
    virtual void setHasSequenceNumber(bool hasSequenceNumber);
    virtual DYMOSequenceNumber& getSequenceNumber();
    virtual const DYMOSequenceNumber& getSequenceNumber() const {return const_cast<AddressBlock*>(this)->getSequenceNumber();}
    virtual void setSequenceNumber(const DYMOSequenceNumber& sequenceNumber);
};

inline void doPacking(cCommBuffer *b, AddressBlock& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AddressBlock& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:53</tt> by nedtool.
 * <pre>
 * message RREQTimer
 * {
 *     IPv4Address target;
 * }
 * </pre>
 */
class INET_API RREQTimer : public ::cMessage
{
  protected:
    IPv4Address target_var;

  private:
    void copy(const RREQTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RREQTimer&);

  public:
    RREQTimer(const char *name=NULL, int kind=0);
    RREQTimer(const RREQTimer& other);
    virtual ~RREQTimer();
    RREQTimer& operator=(const RREQTimer& other);
    virtual RREQTimer *dup() const {return new RREQTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPv4Address& getTarget();
    virtual const IPv4Address& getTarget() const {return const_cast<RREQTimer*>(this)->getTarget();}
    virtual void setTarget(const IPv4Address& target);
};

inline void doPacking(cCommBuffer *b, RREQTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RREQTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:57</tt> by nedtool.
 * <pre>
 * message RREQWaitRREPTimer extends RREQTimer
 * {
 *     int retryCount;
 * }
 * </pre>
 */
class INET_API RREQWaitRREPTimer : public ::DYMO::RREQTimer
{
  protected:
    int retryCount_var;

  private:
    void copy(const RREQWaitRREPTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RREQWaitRREPTimer&);

  public:
    RREQWaitRREPTimer(const char *name=NULL, int kind=0);
    RREQWaitRREPTimer(const RREQWaitRREPTimer& other);
    virtual ~RREQWaitRREPTimer();
    RREQWaitRREPTimer& operator=(const RREQWaitRREPTimer& other);
    virtual RREQWaitRREPTimer *dup() const {return new RREQWaitRREPTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRetryCount() const;
    virtual void setRetryCount(int retryCount);
};

inline void doPacking(cCommBuffer *b, RREQWaitRREPTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RREQWaitRREPTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:61</tt> by nedtool.
 * <pre>
 * message RREQBackoffTimer extends RREQTimer
 * {
 *     int retryCount;
 * }
 * </pre>
 */
class INET_API RREQBackoffTimer : public ::DYMO::RREQTimer
{
  protected:
    int retryCount_var;

  private:
    void copy(const RREQBackoffTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RREQBackoffTimer&);

  public:
    RREQBackoffTimer(const char *name=NULL, int kind=0);
    RREQBackoffTimer(const RREQBackoffTimer& other);
    virtual ~RREQBackoffTimer();
    RREQBackoffTimer& operator=(const RREQBackoffTimer& other);
    virtual RREQBackoffTimer *dup() const {return new RREQBackoffTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRetryCount() const;
    virtual void setRetryCount(int retryCount);
};

inline void doPacking(cCommBuffer *b, RREQBackoffTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RREQBackoffTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:65</tt> by nedtool.
 * <pre>
 * message RREQHolddownTimer extends RREQTimer
 * {
 * }
 * 
 * //
 * // DYMO packets
 * //
 * </pre>
 */
class INET_API RREQHolddownTimer : public ::DYMO::RREQTimer
{
  protected:

  private:
    void copy(const RREQHolddownTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RREQHolddownTimer&);

  public:
    RREQHolddownTimer(const char *name=NULL, int kind=0);
    RREQHolddownTimer(const RREQHolddownTimer& other);
    virtual ~RREQHolddownTimer();
    RREQHolddownTimer& operator=(const RREQHolddownTimer& other);
    virtual RREQHolddownTimer *dup() const {return new RREQHolddownTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RREQHolddownTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RREQHolddownTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:72</tt> by nedtool.
 * <pre>
 * packet DYMOPacket
 * {
 *     int hopLimit;
 * }
 * </pre>
 */
class INET_API DYMOPacket : public ::cPacket
{
  protected:
    int hopLimit_var;

  private:
    void copy(const DYMOPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DYMOPacket&);

  public:
    DYMOPacket(const char *name=NULL, int kind=0);
    DYMOPacket(const DYMOPacket& other);
    virtual ~DYMOPacket();
    DYMOPacket& operator=(const DYMOPacket& other);
    virtual DYMOPacket *dup() const {return new DYMOPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHopLimit() const;
    virtual void setHopLimit(int hopLimit);
};

inline void doPacking(cCommBuffer *b, DYMOPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DYMOPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:76</tt> by nedtool.
 * <pre>
 * packet RteMsg extends DYMOPacket
 * {
 *     int hopCount;
 *     AddressBlock originatorNode;
 *     AddressBlock targetNode;
 *     AddressBlock addedNode[];
 * }
 * </pre>
 */
class INET_API RteMsg : public ::DYMO::DYMOPacket
{
  protected:
    int hopCount_var;
    AddressBlock originatorNode_var;
    AddressBlock targetNode_var;
    AddressBlock *addedNode_var; // array ptr
    unsigned int addedNode_arraysize;

  private:
    void copy(const RteMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RteMsg&);

  public:
    RteMsg(const char *name=NULL, int kind=0);
    RteMsg(const RteMsg& other);
    virtual ~RteMsg();
    RteMsg& operator=(const RteMsg& other);
    virtual RteMsg *dup() const {return new RteMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);
    virtual AddressBlock& getOriginatorNode();
    virtual const AddressBlock& getOriginatorNode() const {return const_cast<RteMsg*>(this)->getOriginatorNode();}
    virtual void setOriginatorNode(const AddressBlock& originatorNode);
    virtual AddressBlock& getTargetNode();
    virtual const AddressBlock& getTargetNode() const {return const_cast<RteMsg*>(this)->getTargetNode();}
    virtual void setTargetNode(const AddressBlock& targetNode);
    virtual void setAddedNodeArraySize(unsigned int size);
    virtual unsigned int getAddedNodeArraySize() const;
    virtual AddressBlock& getAddedNode(unsigned int k);
    virtual const AddressBlock& getAddedNode(unsigned int k) const {return const_cast<RteMsg*>(this)->getAddedNode(k);}
    virtual void setAddedNode(unsigned int k, const AddressBlock& addedNode);
};

inline void doPacking(cCommBuffer *b, RteMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RteMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:86</tt> by nedtool.
 * <pre>
 * //
 * // DYMO RREQ packet
 * //
 * packet RREQ extends RteMsg
 * {
 * }
 * </pre>
 */
class INET_API RREQ : public ::DYMO::RteMsg
{
  protected:

  private:
    void copy(const RREQ& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RREQ&);

  public:
    RREQ(const char *name=NULL, int kind=0);
    RREQ(const RREQ& other);
    virtual ~RREQ();
    RREQ& operator=(const RREQ& other);
    virtual RREQ *dup() const {return new RREQ(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RREQ& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RREQ& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:92</tt> by nedtool.
 * <pre>
 * //
 * // DYMO RREP packet
 * //
 * packet RREP extends RteMsg
 * {
 * }
 * </pre>
 */
class INET_API RREP : public ::DYMO::RteMsg
{
  protected:

  private:
    void copy(const RREP& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RREP&);

  public:
    RREP(const char *name=NULL, int kind=0);
    RREP(const RREP& other);
    virtual ~RREP();
    RREP& operator=(const RREP& other);
    virtual RREP *dup() const {return new RREP(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RREP& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RREP& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:98</tt> by nedtool.
 * <pre>
 * //
 * // DYMO RREP ACK packet
 * //
 * packet RREP_ACK extends DYMOPacket
 * {
 * }
 * </pre>
 */
class INET_API RREP_ACK : public ::DYMO::DYMOPacket
{
  protected:

  private:
    void copy(const RREP_ACK& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RREP_ACK&);

  public:
    RREP_ACK(const char *name=NULL, int kind=0);
    RREP_ACK(const RREP_ACK& other);
    virtual ~RREP_ACK();
    RREP_ACK& operator=(const RREP_ACK& other);
    virtual RREP_ACK *dup() const {return new RREP_ACK(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, RREP_ACK& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RREP_ACK& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/routing/dymo/DYMO.msg:104</tt> by nedtool.
 * <pre>
 * //
 * // DYMO RERR packet
 * //
 * packet RERR extends DYMOPacket
 * {
 *     AddressBlock unreachableNode[];
 * }
 * </pre>
 */
class INET_API RERR : public ::DYMO::DYMOPacket
{
  protected:
    AddressBlock *unreachableNode_var; // array ptr
    unsigned int unreachableNode_arraysize;

  private:
    void copy(const RERR& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RERR&);

  public:
    RERR(const char *name=NULL, int kind=0);
    RERR(const RERR& other);
    virtual ~RERR();
    RERR& operator=(const RERR& other);
    virtual RERR *dup() const {return new RERR(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setUnreachableNodeArraySize(unsigned int size);
    virtual unsigned int getUnreachableNodeArraySize() const;
    virtual AddressBlock& getUnreachableNode(unsigned int k);
    virtual const AddressBlock& getUnreachableNode(unsigned int k) const {return const_cast<RERR*>(this)->getUnreachableNode(k);}
    virtual void setUnreachableNode(unsigned int k, const AddressBlock& unreachableNode);
};

inline void doPacking(cCommBuffer *b, RERR& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RERR& obj) {obj.parsimUnpack(b);}

} // namespace DYMO

#endif // ifndef _DYMO_DYMO_M_H_

